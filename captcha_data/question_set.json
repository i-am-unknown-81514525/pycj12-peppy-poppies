{
    "construct": [
        "{init} {dyn:base}",
        "{init} {dyn:base} {continue} {dyn:part}",
        "{init} {dyn:base} {continue} {dyn:part} {continue} {dyn:part}"
    ],
    "base": [
        {
            "question": "{y}+x",
            "validator": "validator=lambda x: {y}+x",
            "range": {
                "__base__": [1, 65536],
                "y": [-65536, 65536]
            }
        },
        {
            "question": "x-th prime number",
            "validator": "def validator(x):\n    if x == 1:\n        return 2\n    primes_found = 1\n    num = 3\n    while True:\n        if all(num % i != 0 for i in range(3, int(num**0.5) + 1, 2)):\n            primes_found += 1\n            if primes_found == x:\n                return num\n        num += 2",
            "range": {
                "__base__": [1, 2000]
            }
        },
        {
            "question": "[x+{y}]-th prime number",
            "validator": "def validator(x):\n    x+={y}\n    if x == 1:\n        return 2\n    primes_found = 1\n    num = 3\n    while True:\n        if all(num % i != 0 for i in range(3, int(num**0.5) + 1, 2)):\n            primes_found += 1\n            if primes_found == x:\n                return num\n        num += 2",
            "range": {
                "__base__": [1, 2000],
                "y": [1, 2000]
            }
        }
    ],
    "part": [
        {
            "question": "add {y}",
            "validator": "validator=lambda x:x+{y}",
            "range": {
                "y": [-65536, 65536]
            }
        },
        {
            "question": "subtract {y}",
            "validator": "validator=lambda x:x-{y}",
            "range": {
                "y": [-65536, 65536]
            }
        },
        {
            "question": "subtract from {y}",
            "validator": "validator=lambda x:{y}-x",
            "range": {
                "y": [-65536, 65536]
            }
        },
        {
            "question": "multiply by {y}",
            "validator": "validator=lambda x:x*{y}",
            "range": {
                "y": [1, 65536]
            }
        },
        {
            "question": "multiply by {y}",
            "validator": "validator=lambda x:x*{y}",
            "range": {
                "y": [-65536, -1]
            }
        },
        {
            "question": "integer divide {y}",
            "validator": "validator=lambda x:x//{y}",
            "range": {
                "y": [1, 65536]
            }
        },
        {
            "question": "integer divide from {y}",
            "validator": "validator=lambda x:{y}//x",
            "range": {
                "y": [1, 65536]
            }
        },
        {
            "question": "integer divide {y}",
            "validator": "validator=lambda x:x//{y}",
            "range": {
                "y": [-65536, -1]
            }
        },
        {
            "question": "integer divide from {y}",
            "validator": "validator=lambda x:{y}//x",
            "range": {
                "y": [-65536, -1]
            }
        },
        {
            "question": "bitwise XOR by {y}",
            "validator": "validator=lambda x:x^{y}",
            "range": {
                "y": [-65536, 65536]
            }
        },
        {
            "question": "bitwise invert",
            "validator": "validator=lambda x:~x",
            "range": {}
        },
        {
            "question": "bitwise AND by {y}",
            "validator": "validator=lambda x:x&{y}",
            "range": {
                "y": [-65536, 65536]
            }
        },
        {
            "question": "bitwise OR by {y}",
            "validator": "validator=lambda x:x|{y}",
            "range": {
                "y": [-65536, 65536]
            }
        }
    ],
    "init": [
        "Write a function `calc(x: int) -> int` to calculate",
        "Write a function `calc(x: int) -> int` to get",
        "Write a function `calc(x: int)` to calculate",
        "Write a function `calc(x: int)` to get",
        "Write `calc(x: int) -> int` such that it calculate",
        "Write `calc(x: int) -> int` such that it get",
        "Write `calc(x: int)` such that it calculate",
        "Write `calc(x: int)` such that it get"
    ],
    "continue": [", then", ", and then"]
}
